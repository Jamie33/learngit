{"url_object_id": "6dc6e928199fafa86ce672b2bf1253e2", "title": "给初学者看的 shuf 命令教程", "url": "http://blog.jobbole.com/113985/", "cover_url": ["http://jbcdn2.b0.upaiyun.com/2017/05/77d80105fd15f2465894827e23cc4842.jpeg"], "date": "2018/05/14", "vote_num": "1", "fav_num": null, "comments": 0, "content": "原文出处： Sk   译文出处：Linux中国/geekpi   shuf 命令用于在类 Unix 操作系统中生成随机排列。使用 shuf 命令，我们可以随机打乱给定输入文件的行。shuf 命令是 GNU Coreutils 的一部分，因此你不必担心安装问题。在这个简短的教程中，让我向你展示一些 shuf 命令的例子。\n\n带例子的 shuf 命令教程\n我有一个名为 ostechnix.txt 的文件，内容如下：\r\n\r\n\t\t\r\n\t\t\r\n\t\t\t\r\n\t\t\t\r\n\t\t\t\r\n\t\t\t\n$ cat ostechnix.txt\r\nline1\r\nline2\r\nline3\r\nline4\r\nline5\r\nline6\r\nline7\r\nline8\r\nline9\r\nline10\r\n\r\n\t\t\t\r\n\t\t\t\t\r\n\t\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\t\t123456789101112\r\n\t\t\t\t\r\n\t\t\t\t\t\t$ cat ostechnix.txtline1line2line3line4line5line6line7line8line9line10 \r\n\t\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\r\n\t\t\r\n\r\n现在让我们以随机顺序显示上面的行。为此，请运行：\r\n\r\n\t\t\r\n\t\t\r\n\t\t\t\r\n\t\t\t\r\n\t\t\t\r\n\t\t\t\n$ shuf ostechnix.txt\r\nline2\r\nline8\r\nline5\r\nline10\r\nline7\r\nline1\r\nline4\r\nline6\r\nline9\r\nline3\r\n\r\n\t\t\t\r\n\t\t\t\t\r\n\t\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\t\t123456789101112\r\n\t\t\t\t\r\n\t\t\t\t\t\t$ shuf ostechnix.txtline2line8line5line10line7line1line4line6line9line3 \r\n\t\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\r\n\t\t\r\n\r\n看到了吗？上面的命令将名为 ostechnix.txt 中的行随机排列并输出了结果。\n你可能想将输出写入另一个文件。例如，我想将输出保存到 output.txt 中。为此，请先创建 output.txt：\r\n\r\n\t\t\r\n\t\t\r\n\t\t\t\r\n\t\t\t\r\n\t\t\t\r\n\t\t\t\n$ touch output.txt\r\n\r\n\t\t\t\r\n\t\t\t\t\r\n\t\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\t\t12\r\n\t\t\t\t\r\n\t\t\t\t\t\t$ touch output.txt \r\n\t\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\r\n\t\t\r\n\r\n然后，像下面使用 -o 标志将输出写入该文件：\r\n\r\n\t\t\r\n\t\t\r\n\t\t\t\r\n\t\t\t\r\n\t\t\t\r\n\t\t\t\n$ shuf ostechnix.txt -o output.txt\r\n\r\n\t\t\t\r\n\t\t\t\t\r\n\t\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\t\t12\r\n\t\t\t\t\r\n\t\t\t\t\t\t$ shuf ostechnix.txt -o output.txt \r\n\t\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\r\n\t\t\r\n\r\n上面的命令将随机随机打乱 ostechnix.txt 的内容并将输出写入 output.txt。你可以使用命令查看 output.txt 的内容：\r\n\r\n\t\t\r\n\t\t\r\n\t\t\t\r\n\t\t\t\r\n\t\t\t\r\n\t\t\t\n$ cat output.txt\r\n\r\nline2\r\nline8\r\nline9\r\nline10\r\nline1\r\nline3\r\nline7\r\nline6\r\nline4\r\nline5\r\n\r\n\t\t\t\r\n\t\t\t\t\r\n\t\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\t\t12345678910111213\r\n\t\t\t\t\r\n\t\t\t\t\t\t$ cat output.txt line2line8line9line10line1line3line7line6line4line5 \r\n\t\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\r\n\t\t\r\n\r\n我只想显示文件中的任意一行。我该怎么做？很简单！\r\n\r\n\t\t\r\n\t\t\r\n\t\t\t\r\n\t\t\t\r\n\t\t\t\r\n\t\t\t\n$ shuf -n 1 ostechnix.txt\r\nline6\r\n\r\n\t\t\t\r\n\t\t\t\t\r\n\t\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\t\t123\r\n\t\t\t\t\r\n\t\t\t\t\t\t$ shuf -n 1 ostechnix.txtline6 \r\n\t\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\r\n\t\t\r\n\r\n同样，我们可以选择前 “n” 个随机条目。以下命令将只显示前五个随机条目：\r\n\r\n\t\t\r\n\t\t\r\n\t\t\t\r\n\t\t\t\r\n\t\t\t\r\n\t\t\t\n$ shuf -n 5 ostechnix.txt\r\nline10\r\nline4\r\nline5\r\nline9\r\nline3\r\n\r\n\t\t\t\r\n\t\t\t\t\r\n\t\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\t\t1234567\r\n\t\t\t\t\r\n\t\t\t\t\t\t$ shuf -n 5 ostechnix.txtline10line4line5line9line3 \r\n\t\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\r\n\t\t\r\n\r\n如下所示，我们可以直接使用 -e 标志传入输入，而不是从文件中读取行：\r\n\r\n\t\t\r\n\t\t\r\n\t\t\t\r\n\t\t\t\r\n\t\t\t\r\n\t\t\t\n$ shuf -e line1 line2 line3 line4 line5\r\nline1\r\nline3\r\nline5\r\nline4\r\nline2\r\n\r\n\t\t\t\r\n\t\t\t\t\r\n\t\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\t\t1234567\r\n\t\t\t\t\r\n\t\t\t\t\t\t$ shuf -e line1 line2 line3 line4 line5line1line3line5line4line2 \r\n\t\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\r\n\t\t\r\n\r\n你也可以传入数字：\r\n\r\n\t\t\r\n\t\t\r\n\t\t\t\r\n\t\t\t\r\n\t\t\t\r\n\t\t\t\n$ shuf -e 1 2 3 4 5\r\n3\r\n5\r\n1\r\n4\r\n2\r\n\r\n\t\t\t\r\n\t\t\t\t\r\n\t\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\t\t1234567\r\n\t\t\t\t\r\n\t\t\t\t\t\t$ shuf -e 1 2 3 4 535142 \r\n\t\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\r\n\t\t\r\n\r\n要快速在给定范围选择一个，请改用此命令：\r\n\r\n\t\t\r\n\t\t\r\n\t\t\t\r\n\t\t\t\r\n\t\t\t\r\n\t\t\t\n$ shuf -n 1 -e 1 2 3 4 5\r\n\r\n\t\t\t\r\n\t\t\t\t\r\n\t\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\t\t12\r\n\t\t\t\t\r\n\t\t\t\t\t\t$ shuf -n 1 -e 1 2 3 4 5 \r\n\t\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\r\n\t\t\r\n\r\n或者，选择下面的任意三个随机数字：\r\n\r\n\t\t\r\n\t\t\r\n\t\t\t\r\n\t\t\t\r\n\t\t\t\r\n\t\t\t\n$ shuf -n 3 -e 1 2 3 4 5\r\n3\r\n5\r\n1\r\n\r\n\t\t\t\r\n\t\t\t\t\r\n\t\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\t\t12345\r\n\t\t\t\t\r\n\t\t\t\t\t\t$ shuf -n 3 -e 1 2 3 4 5351 \r\n\t\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\r\n\t\t\r\n\r\n我们也可以在特定范围内生成随机数。例如，要显示 1 到 10 之间的随机数，只需使用：\r\n\r\n\t\t\r\n\t\t\r\n\t\t\t\r\n\t\t\t\r\n\t\t\t\r\n\t\t\t\n$ shuf -i 1-10\r\n1\r\n9\r\n8\r\n2\r\n4\r\n7\r\n6\r\n3\r\n10\r\n5\r\n\r\n\t\t\t\r\n\t\t\t\t\r\n\t\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\t\t123456789101112\r\n\t\t\t\t\r\n\t\t\t\t\t\t$ shuf -i 1-1019824763105 \r\n\t\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\r\n\t\t\r\n\r\n有关更多详细信息，请参阅手册页。\r\n\r\n\t\t\r\n\t\t\r\n\t\t\t\r\n\t\t\t\r\n\t\t\t\r\n\t\t\t\n$ man shuf\r\n\r\n\t\t\t\r\n\t\t\t\t\r\n\t\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\t\t12\r\n\t\t\t\t\r\n\t\t\t\t\t\t$ man shuf \r\n\t\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\r\n\t\t\r\n\r\n今天就是这些。还有更多更好的东西。敬请关注！\n\n\r\n        \r\n        \r\n        \n    \n         1 赞\n          收藏\n\n                      评论", "tags": "IT技术,Linux", "cover_url_path": "full/d1b17b98748a74826464a08e6d30a4ee1b15b171.jpg"}
{"url_object_id": "97dd29d801309a1f0316b5b23e4fbb18", "title": "分布式之数据库和缓存双写一致性方案解析", "url": "http://blog.jobbole.com/113992/", "cover_url": ["http://jbcdn2.b0.upaiyun.com/2017/03/4bae6998d00f180d42c7da716e3d0bb2.jpg"], "date": "2018/05/17", "vote_num": "1", "fav_num": null, "comments": 1, "content": "原文出处： 孤独烟   引言\n为什么写这篇文章？\n首先，缓存由于其高并发和高性能的特性，已经在项目中被广泛使用。在读取缓存方面，大家没啥疑问，都是按照下图的流程来进行业务操作。\n\n但是在更新缓存方面，对于更新完数据库，是更新缓存呢，还是删除缓存。又或者是先删除缓存，再更新数据库，其实大家存在很大的争议。目前没有一篇全面的博客，对这几种方案进行解析。于是博主战战兢兢，顶着被大家喷的风险，写了这篇文章。\n文章结构\n本文由以下三个部分组成\n1、讲解缓存更新策略\n2、对每种策略进行缺点分析\n3、针对缺点给出改进方案\n正文\n先做一个说明，从理论上来说，给缓存设置过期时间，是保证最终一致性的解决方案。这种方案下，我们可以对存入缓存的数据设置过期时间，所有的写操作以数据库为准，对缓存操作只是尽最大努力即可。也就是说如果数据库写成功，缓存更新失败，那么只要到达过期时间，则后面的读请求自然会从数据库中读取新值然后回填缓存。因此，接下来讨论的思路不依赖于给缓存设置过期时间这个方案。\n在这里，我们讨论三种更新策略：\n\n先更新数据库，再更新缓存\n先删除缓存，再更新数据库\n先更新数据库，再删除缓存\n\n应该没人问我，为什么没有先更新缓存，再更新数据库这种策略。\n(1)先更新数据库，再更新缓存\n这套方案，大家是普遍反对的。为什么呢？有如下两点原因。\n原因一（线程安全角度）\n同时有请求A和请求B进行更新操作，那么会出现\n（1）线程A更新了数据库\n（2）线程B更新了数据库\n（3）线程B更新了缓存\n（4）线程A更新了缓存\n这就出现请求A更新缓存应该比请求B更新缓存早才对，但是因为网络等原因，B却比A更早更新了缓存。这就导致了脏数据，因此不考虑。\n原因二（业务场景角度）\n有如下两点：\n（1）如果你是一个写数据库场景比较多，而读数据场景比较少的业务需求，采用这种方案就会导致，数据压根还没读到，缓存就被频繁的更新，浪费性能。\n（2）如果你写入数据库的值，并不是直接写入缓存的，而是要经过一系列复杂的计算再写入缓存。那么，每次写入数据库后，都再次计算写入缓存的值，无疑是浪费性能的。显然，删除缓存更为适合。\n接下来讨论的就是争议最大的，先删缓存，再更新数据库。还是先更新数据库，再删缓存的问题。\n(2)先删缓存，再更新数据库\n该方案会导致不一致的原因是。同时有一个请求A进行更新操作，另一个请求B进行查询操作。那么会出现如下情形:\n（1）请求A进行写操作，删除缓存\n（2）请求B查询发现缓存不存在\n（3）请求B去数据库查询得到旧值\n（4）请求B将旧值写入缓存\n（5）请求A将新值写入数据库\n上述情况就会导致不一致的情形出现。而且，如果不采用给缓存设置过期时间策略，该数据永远都是脏数据。\n那么，如何解决呢？采用延时双删策略\n伪代码如下\n\n\r\n\r\n\t\t\r\n\t\t\r\n\t\t\t\r\n\t\t\t\r\n\t\t\t\r\n\t\t\t\npublic void write(String key,Object data){\r\n        redis.delKey(key);\r\n        db.updateData(data);\r\n        Thread.sleep(1000);\r\n        redis.delKey(key);\r\n    }\r\n\t\t\t\r\n\t\t\t\t\r\n\t\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\t\t123456\r\n\t\t\t\t\r\n\t\t\t\t\t\tpublic void write(String key,Object data){        redis.delKey(key);        db.updateData(data);        Thread.sleep(1000);        redis.delKey(key);    }\r\n\t\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\r\n\t\t\r\n\r\n\n\n转化为中文描述就是\n（1）先淘汰缓存\n（2）再写数据库（这两步和原来一样）\n（3）休眠1秒，再次淘汰缓存\n这么做，可以将1秒内所造成的缓存脏数据，再次删除。\n那么，这个1秒怎么确定的，具体该休眠多久呢？\n针对上面的情形，读者应该自行评估自己的项目的读数据业务逻辑的耗时。然后写数据的休眠时间则在读数据业务逻辑的耗时基础上，加几百ms即可。这么做的目的，就是确保读请求结束，写请求可以删除读请求造成的缓存脏数据。\n如果你用了mysql的读写分离架构怎么办？\nok，在这种情况下，造成数据不一致的原因如下，还是两个请求，一个请求A进行更新操作，另一个请求B进行查询操作。\n（1）请求A进行写操作，删除缓存\n（2）请求A将数据写入数据库了，\n（3）请求B查询缓存发现，缓存没有值\n（4）请求B去从库查询，这时，还没有完成主从同步，因此查询到的是旧值\n（5）请求B将旧值写入缓存\n（6）数据库完成主从同步，从库变为新值\n上述情形，就是数据不一致的原因。还是使用双删延时策略。只是，睡眠时间修改为在主从同步的延时时间基础上，加几百ms。\n采用这种同步淘汰策略，吞吐量降低怎么办？\nok，那就将第二次删除作为异步的。自己起一个线程，异步删除。这样，写的请求就不用沉睡一段时间后了，再返回。这么做，加大吞吐量。\n第二次删除,如果删除失败怎么办？\n这是个非常好的问题，因为第二次删除失败，就会出现如下情形。还是有两个请求，一个请求A进行更新操作，另一个请求B进行查询操作，为了方便，假设是单库：\n（1）请求A进行写操作，删除缓存\n（2）请求B查询发现缓存不存在\n（3）请求B去数据库查询得到旧值\n（4）请求B将旧值写入缓存\n（5）请求A将新值写入数据库\n（6）请求A试图去删除请求B写入对缓存值，结果失败了。\nok,这也就是说。如果第二次删除缓存失败，会再次出现缓存和数据库不一致的问题。\n如何解决呢？\n具体解决方案，且看博主对第(3)种更新策略的解析。\n(3)先更新数据库，再删缓存\n首先，先说一下。老外提出了一个缓存更新套路，名为《Cache-Aside pattern》。其中就指出\n\n失效：应用程序先从cache取数据，没有得到，则从数据库中取数据，成功后，放到缓存中。\n命中：应用程序从cache中取数据，取到后返回。\n更新：先把数据存到数据库中，成功后，再让缓存失效。\n\n另外，知名社交网站facebook也在论文《Scaling Memcache at Facebook》中提出，他们用的也是先更新数据库，再删缓存的策略。\n这种情况不存在并发问题么？\n不是的。假设这会有两个请求，一个请求A做查询操作，一个请求B做更新操作，那么会有如下情形产生\n（1）缓存刚好失效\n（2）请求A查询数据库，得一个旧值\n（3）请求B将新值写入数据库\n（4）请求B删除缓存\n（5）请求A将查到的旧值写入缓存\nok，如果发生上述情况，确实是会发生脏数据。\n然而，发生这种情况的概率又有多少呢？\n发生上述情况有一个先天性条件，就是步骤（3）的写数据库操作比步骤（2）的读数据库操作耗时更短，才有可能使得步骤（4）先于步骤（5）。可是，大家想想，数据库的读操作的速度远快于写操作的（不然做读写分离干嘛，做读写分离的意义就是因为读操作比较快，耗资源少），因此步骤（3）耗时比步骤（2）更短，这一情形很难出现。\n假设，有人非要抬杠，有强迫症，一定要解决怎么办？\n如何解决上述并发问题？\n首先，给缓存设有效时间是一种方案。其次，采用策略（2）里给出的异步延时删除策略，保证读请求完成以后，再进行删除操作。\n还有其他造成不一致的原因么？\n有的，这也是缓存更新策略（2）和缓存更新策略（3）都存在的一个问题，如果删缓存失败了怎么办，那不是会有不一致的情况出现么。比如一个写数据请求，然后写入数据库了，删缓存失败了，这会就出现不一致的情况了。这也是缓存更新策略（2）里留下的最后一个疑问。\n如何解决？\n提供一个保障的重试机制即可，这里给出两套方案。\n方案一：\n如下图所示\n\n流程如下所示\n（1）更新数据库数据；\n（2）缓存因为种种问题删除失败\n（3）将需要删除的key发送至消息队列\n（4）自己消费消息，获得需要删除的key\n（5）继续重试删除操作，直到成功\n然而，该方案有一个缺点，对业务线代码造成大量的侵入。于是有了方案二，在方案二中，启动一个订阅程序去订阅数据库的binlog，获得需要操作的数据。在应用程序中，另起一段程序，获得这个订阅程序传来的信息，进行删除缓存操作。\n方案二：\n\n流程如下图所示：\n（1）更新数据库数据\n（2）数据库会将操作信息写入binlog日志当中\n（3）订阅程序提取出所需要的数据以及key\n（4）另起一段非业务代码，获得该信息\n（5）尝试删除缓存操作，发现删除失败\n（6）将这些信息发送至消息队列\n（7）重新从消息队列中获得该数据，重试操作。\n备注说明：上述的订阅binlog程序在mysql中有现成的中间件叫canal，可以完成订阅binlog日志的功能。至于oracle中，博主目前不知道有没有现成中间件可以使用。另外，重试机制，博主是采用的是消息队列的方式。如果对一致性要求不是很高，直接在程序中另起一个线程，每隔一段时间去重试即可，这些大家可以灵活自由发挥，只是提供一个思路。\n总结\n本文其实是对目前互联网中已有的一致性方案，进行了一个总结。对于先删缓存，再更新数据库的更新策略，还有方案提出维护一个内存队列的方式，博主看了一下，觉得实现异常复杂，没有必要，因此没有必要在文中给出。最后，希望大家有所收获。\n参考文献\n1、主从DB与cache一致性\n2、缓存更新的套路\n\r\n        \r\n        \r\n        \n    \n         1 赞\n          收藏\n\n                     1 评论", "tags": "IT技术,分布式,数据库", "cover_url_path": "full/117976068e2e847f1067d25ea3fa90a3b5a60f3f.jpg"}
{"url_object_id": "559edfe4360defce6adda9e865d11934", "title": "我似乎理解了编程的意义", "url": "http://blog.jobbole.com/112098/", "cover_url": ["http://jbcdn2.b0.upaiyun.com/2016/07/b82c41ce36630a47a22e10059671eb52.jpg"], "date": "2018/05/21", "vote_num": "1", "fav_num": null, "comments": 1, "content": "原文出处： 技匠（微信公众号：techmask）   编程的意义是什么，我又为什么要编程呢？这是一个不时会浮现在我脑海中的问题，它来得并不频繁，但每次却都伴随着对自己职业生涯或人生目标的质疑而产生，令我感到些许困惑和不安。而在这十几年的职业生涯中，我也似乎总能在每个阶段为自己找到一个继续热爱编程的理由，直到它已无法解答再一次疑惑的产生。就这样一次又一次的循环往复，我似乎渐渐理解了编程的意义……\n\n编程是一项技能\n回想大学毕业刚成为一名程序员时，自己对技术是如此狂热，我不断地购买各类技术书籍，几乎所有的业余时间也都被用来钻研技术，提高自己的编程能力。我也因此很快成了同一批入职新人中，编码效率和质量最突出的一个。而在那段时间里所做的技术积累，也成了我日后工作的坚实基础，编程作为一项技能已经深深地嵌入到了我的身体里。\n即使到了今天，我仍非常怀念那段心无旁骛，一心钻研技术的日子。我为能在工作中写出的每一行优秀代码而兴奋，更为每一天能在技术上取得的点滴进步而喜悦，一切都是那么单纯，编程的意义对于那时的我来说就在于技术本身。\n编程是去解决问题\n“能力越大，责任也也大”，这句电影“蜘蛛侠”中的经典台词同样适用于程序员的职业生涯。随着技术能力的提升以及工作中获得的认可，我的职位也由原来的初级程序员变为了资深开发工程师，以及后来的架构师。相应的，除了编程之外，我工作中的很大一部分时间需要用来与用户进行沟通，并分析他们提出的需求。对于我来说这个角色转换的过程，是艰难甚至有些痛苦的。 我不得不用自己最薄弱的沟通技能去和用户打交道，更要命的是我所习惯使用的那些技术语言有时很难让他们理解。\n我很快意识到自己已不再是那个只需被动接受任务安排，并将自己的编程工作完成好就万事大吉的初级程序员。除了技术之外，我更需要能够突破程序员思维，去发现用户需求背后所隐含的真正问题。我比以前变得更加务实，不再刻意追求技术的高深，而是尽可能从问题本身出发，选择最有效的技术手段去解决它。\n此时，编程的意义也发生了改变，它已不再局限于技术本身，而成了解决问题的理想工具。\n编程是在表达，也是在创作\n就这样又过了几年，当“为什么要编程？”这个问题再次摆在我的面前时，自己也已过了而立之年。对于大多数中国程序员来说，这个年纪已经算是高龄，甚至还有很多人会认为 30 岁还在编程，一定是混得不够好吧。当然，对于这些质疑我也总是一笑了之。其实，在此之前我也有过很多转型的机会，比如去业务部门，或是转作管理等等，但最终我还是选择留在了技术岗位上，因为我觉得编程仍是我最喜欢的，或许也是我唯一擅长的吧。\n而这个时期也成了我整个程序员生涯的黄金期，我写了公司的核心框架以及一些重要业务系统的核心算法。我很享受这段时光，因为我已几乎感受不到那些技术上的牵绊，我更像雕刻师使用手中的刻刀一般，自如地运用编程来实现那些我认为优秀的东西。\n编程对于我来说已不再是一项技能或是工具，我是在通过编程进行着自我表达与创作，这种感受带给了我极大的自由度，而我也从中感受到了前所未有的喜悦与乐趣。\n编程是为了留下痕迹\n最终我还是走上了管理岗位，这里面有很多个人无法左右的因素（包括大环境、家庭、经济等等）。但我仍然更乐意被大家称为程序员或者“老”程序员。就像在简书的自我介绍中，我总是把全栈工程师放在那些“头衔”的第一位，我也还在利用业余时间做自己喜欢的开源或个人项目。当我再一次问自己“为什么要编程”时，获得了与以往不一样的感悟：或许我们编程是为了能够留下一些痕迹吧。\n公司里最近都在为一个老系统的升级问题发愁，这个系统已经运行了将近 20 年时间了，为了升级系统，大家不得不深入到这个系统的框架中，去读底层代码。我们读到了一位已经退休的美国同事Bill所实现的数据库连接池代码。在那个时候JAVA刚开始流行，还没有像 Spring 这样的框架，或是如 Hibernate 或 MyBatis 这样标准的持久层实现，这个系统中所有的数据库连接池及核心持久层代码都是由我的这位美国同事写的，这些代码让整个系统稳定运行了将近20年，大家都不禁为他高超的技术水平发出由衷的赞叹。\n我还认识一位从事证券交易软件研发的公司 CTO，看年纪应该已经接近 50 了，但他仍然在亲自写着那些证券交易的核心代码。当我问他到了这个年龄和职位，为什么还要坚持写代码时，他告诉我，当他看到自己所写的代码每天在支撑着千亿级的证券交易时，他感到非常兴奋和自豪，并不断地希望能够通过自己的努力将它做得更好。\n我的这个美国同事不会听到大家为他十几年前所代码发出的zan叹，股民们也不会知道这位 CTO 所写的代码正在支撑着他们的日常交易。那些优秀的代码是他们留下的痕迹，我们不能确定这些痕迹能够保留多久，或许几年，或许更短，但它们都曾经在我们的日常生活中产生了重要的价值，而新的未来也将构建在这些痕迹的基础之上，我想这可能才是编程的意义所在吧。\n我似乎理解了编程的意义，但我明白未来的某一天，我一定还会问自己同样的问题——为什么要编程，希望到那个时候自己还能是那个热爱编程，有着一颗匠心的“技匠”吧……\n\r\n        \r\n        \r\n        \n    \n         1 赞\n          收藏\n\n                     1 评论", "tags": "职场,程序员,职场", "cover_url_path": "full/8d41e17ba24bd494b959911d8123d0072c41e2a8.jpg"}
{"url_object_id": "cda2e6399ff30560f3a49b7fb8c7280a", "title": "是什么让初级工程师走投无路？", "url": "http://blog.jobbole.com/113954/", "cover_url": ["http://jbcdn2.b0.upaiyun.com/2018/03/1fd843979d2a6757332bedd49c9c8d80.png"], "date": "2018/05/24", "vote_num": "1", "fav_num": null, "comments": 1, "content": "本文由 伯乐在线 - tsteho 翻译，艾凌风 校稿。未经许可，禁止转载！英文出处：Melissa Mcewen。欢迎加入翻译组。虽然有非常多的初级工程师，但是并没有非常多的职位给他们。\n\n几个月前，我参加了一场针对技术领域女性的活动。很多参加者中是新的开发者，毕业于编程学校或者计算机科学课程。几乎所有人都告诉我，她们在获得第一份工作时遇到了麻烦。\n我很幸运。我在大学的第一份“真正”工作是 2010 年哥伦比亚大学的“初级应用程序开发人员”。现如今，甚至找不到一个招聘初级开发者岗位的招聘帖。发这些招聘帖的人说他们被淹没在了简历中。然而优秀的公司又抱怨找不到好的工程师。\n我想知道这是为什么？\n我不知道这样做，具体来说能够为我们节省多少成本，毕竟我不参与公司的运营。但是我知道很多公司对我说过：「我们不雇佣初级工程师的原因是，让高级工程师花时间给他们提供指导，对我们来说成本太高了。」我已经了解高级工程师的价格，因为我就是其中之一，并且为了预估项目预算，项目经理曾让我给项目分配时间。我知道的价格区间是 190 ~ 300 美元每小时。这就是很多公司认为雇佣初级工程师是一笔损失的原因。\n我并不这么认为：没有高级工程师能够一直高效工作一整天。公司对人力成本的焦虑就像鳄鱼的眼泪，（至少以我的观点来说）他们刻意不去思考浪费在很多事物上的时间，比如开会。\n但让我们来做个假设，他们将初级开发者的职位重新加入到团队。另一个问题出现了：高级工程师根本没有与初级工程师合作或者培训他人的经验。当我第一次开始与初级工程师合作时，我不知道该如何去做。我感到迷茫和困惑。我所待的公司基本上就是这样的态度：“让他们有事可做，让他们可以从中学到东西。”但是，这样做真的不可持续。\n我寻找资源，但是并没有找到。如果你知道任何资源，请在留言中通知我。我最终拼凑了各种课程和不同作业。\n但令人惊叹的是，我在做这件事时学到了很多东西。直到我必须解释 Javascript 语言的特性，我才觉得我真的深入地理解了它们。我为教学开发的一些工具最终付诸于项目。\n现在，有一些时候令我感到沮丧。特别是当项目经理或其他经理不了解现实状况的时候。他们总觉得，这些人教了就马上能够进行开发，但这之间有个消化和理解的过程。\n我认为我想说的是：整个软件开发生态系统需要初级工程师以保持健康。培训他们有成本，但也有好处。\n我建议那些想要再次招聘初级工程师的公司，投入一些时间用来制定一个大纲，用来帮助高级工程师以及任何与他们合作的人员有效地辅导。并且说明下这个严峻的现实。\n就像并不是所有初级工程师能够成为成功的开发者。那样的话，你会做什么呢？抱怨辅导你的高级工程师？或者追逐那些奋斗于通往成功领域（如项目管理、销售工程师或者其他非开发的角色）的人。在这些领域，软件技能也是非常重要的。\n并且并不是所有的高级工程师能够成为成功的导师。很多杰出的工程师不具备这一特质。他们应该避免扮演这样的角色。对于那些必须担任导师这一角色的人，如果他们没做好，我们也不应该苛责他们。我曾在一个团队中给初级开发者提供大部分的指导。与其他工程师所做的工作相比，这被认为不是“真正”的工作，这后来也让我不太愿意担当这个角色。是的，我会将性别考虑进去，因为我是一位女性，并且当女性担任类似这种角色，受刻板印象的影响，她们总被认为是“训导员”。那意味着更低的声誉，更低的声誉意味着更少的工资。\n话虽这么说，但如果没有提及一些其他阻碍初级工程师的经济问题，我不足以写下这篇文章。最近，因为一个活动，我拜访了一家公司，他们大概的意思就是说，现在所有“容易”的工作都已外包给另一个国家。这些工作以前都是初级工程师做的。之后有了自动化。我还是初级工程师时许多需要亲自做的工作，现在都可以自动化处理了。\n对于那些初级工程师，找到你的第一份工作正变得越来越困难。你可能不得不做一些我不愿意推荐的事，比如免费给各种项目打工。如果你确实选择了一个非常好的开源项目，你可以将它写到简历上。我不太倾向于推荐为“创业公司”免费打工。\n你也要寻找你自己的导师。现场见面会是最好的方式，虽然我明白并不是每个人都喜欢这样，因此你可以试试 Slack 和 Discord 聊天应用。不过就像很多约会一样，这也会变得糟糕。你将被多次的拒绝。你将做一些糟糕的、甚至完全失败的项目，因为和商业项目的人员相比，免费项目的工作人员一般有点更古里古怪。就像一个初级工程师告诉我的：他们不再去某个见面会，因为他们之前做的项目彻底地失败了。我不得不告诉他们应该继续寻找项目，但心中要明白大多数项目都不是完善的。\n对我而言，我很高兴为参加见面会的人提供辅导。在这些背景下，我也要努力地制定一份更正式的导师计划。\n我不确定整个行业的解决方案是什么。我不确定缺乏初级工程师的公司是不平衡的还是聪明的。实际情况是，大多数软件开发人员不会长时间呆在一个地方，所以也许投入大量资源来培训人员是没有意义的。或者说，这个行业也许应该问问自己，为什么人们不停地跳槽？也许是因为大多数公司都很糟糕，或者对我们很多人来说，这是提高薪水的唯一途径。我可以等待一个愚蠢的、毫无意义的年度“绩效评估”让我涨 1％ 的工资。或者投递简历，通过面试，拿到 10％ 或更多的工资涨幅。\n这不仅仅是个别公司不够完善的信号，也是整个行业不够完善的信号。\n\r\n        \r\n        \r\n        \n    \n         1 赞\n          收藏\n\n                     1 评论\n        \n        \n        \n        \n        \n            \n            \n            \n            \n            \n        \n\n    \n\n\n\n\r\n        \r\n\r\n\r\n\t\r\n\t\r\n\t关于作者：tsteho\r\n\t\r\n\t\r\n\t\t\r\n\t\t\t\r\n\t\t\r\n\t\r\n\r\n    \r\n\r\n        \r\n            Python爱好者        \r\n        \r\n             个人主页 ·\r\n             我的文章\r\n\r\n             ·  13 ·", "tags": "职场,程序员,职场", "cover_url_path": "full/c387e396af4df71c22f480eba98289a1e8a86b87.jpg"}
{"url_object_id": "41201d7935af5be0d5b31cfa94a23f85", "title": "JAVA 程序员需要用到 10 个测试框架和库", "url": "http://blog.jobbole.com/113952/", "cover_url": ["http://jbcdn2.b0.upaiyun.com/2015/11/58175e1df62779046a3a4e2483575937.jpg"], "date": "2018/05/14", "vote_num": "1", "fav_num": null, "comments": 0, "content": "本文由 伯乐在线 - 搬砖大师傅 翻译，艾凌风 校稿。未经许可，禁止转载！英文出处：Javin Paul  。欢迎加入翻译组。\n想要提高你的自动化测试技术？以下是 10 个优秀的测试框架和库，以及它们常见用法的概述。\n最近我写了一些文章，关于 Java 程序员今年应该学习什么，例如编程语言，库和框架等，如果只能学习或提高其中一项，那必然是自动化测试技能。\n测试是专业程序员区别于业余程序员的一项指标，作为专业程序员，并非必须采用 TDD，BDD 或其它测试方法论，但最低标准是通过编写代码的方式，来自动化测试自己的代码。\n许多 Java 程序员编写单元测试和集成测试，使用 Jenkins、TeamCity 等持续集成工具，在构建阶段自动运行。\n如果还有人对程序员是否应该关注自动化测试存有疑问，那么让我来回答，随着 DevOps 理念的增强和角色的涌现，自动化测试的重要性正在呈指数型增长。\n企业通常青睐那种擅长编写单元测试的程序员，这些程序员对各种单元测试框架、库和工具有着丰富的知识，比如 JUnit，Selenium，REST-Assured，Spock 框架等。\n作为 Java 程序员，我们在截然不同的领域工作，从编写 Java 核心代码到 JSP 页面，REST API，甚至有时为了构建自动化而去编写 Groovy 脚本，这就要求我们必需了解不同的自动化测试工具。\n举一个例子，很长一段时间内，我只了解 JUnit，但当不得不测试 JSP 页面时，我却束手无策，直到我找到了 Selenium。REST Assured 是另一个类似的例子，我通常使用 curl 命令测试 REST API，但 REST Assured 将 REST API 的单元测试水平提升到了另一个层次。\nJava 程序员需要用到十大单元测试和自动化集成测试工具\n我认为一个优秀的程序员，必然能够很好地利用手头上的工具，因此我总在业余时间学习和探索新的工具和库，以下列表是我部分研究成果。\n在这篇文章中，我将分享 10 个最为优秀且必不可少的工具，框架和库，这些可以帮助 java 程序员在各类 java 项目中编写单元测试和集成测试。\nJUnit\nJUnit 无须赘述，即便是初级Java程序员，可能也已经听说过它，你可以使用它编写 Java 代码的单元测试。\n几乎所有主流 IDE，例如 Eclipse，NetBeans 和 IntelliJ，都集成了 JUnit，可以直接在这些IDE中编写和运行单元测试。\n大多数人仍在使用 JUnit 4，即使 JUnit 5 已经发布，它很可能是今年下一个热点。通过 JUnit 5，可以将 JUnit 同时应用于单元测试和集成测试，并且它还支持 Java 8 的特性。\n\nREST Assured\n用 Java 语言测试和验证 REST 服务，要难于 Groovy 这类动态语言。\nREST Assured 将这类语言的易用性带入了 Java 领域，是一个优秀的 REST API 的集成测试工具。\n\nSelenium\nSelenium 很可能是最流行的 Java UI 测试工具了，它可以让你在不必启动浏览器的情况下测试 JSP 页面。\n你可以使用 JUnit 和 Selenium 来测试 Web 程序的界面，它甚至允许你编写 Web 应用程序的验收测试。\n\nTestNG\nTestNG 是一个测试框架，其灵感来自 JUnit 和 NUnit，但同时引入了一些新的功能，使其功能更强大，使用更方便。例如可以使用注解，在任意大的线程池中，配置各种可用策略进行测试（例如所有方法都在自己的线程中，每一个测试类使用一个线程等）。\n因为 TestNG 使用 JUnit 4 的注解，同时又集成了 HAMCSTREST 匹配器，它与 JUnit 的差异已经减小了，但两者如何选择，这取决于你。\n\nMockito\nJava 类有许多 Mock 框架，例如 PowerMock 和 JMock，但我个人偏向于 Mockito，因为它有简单的 API，优秀的文档以及大量的示例。\nMocking 是现代单元测试的一项关键技术，因为它允许你在没有任何依赖的情况下独立测试代码，这就是为什么我鼓励每个 Java 程序员在学习 JUnit 的同时，一起学习 Mocking 框架的原因。\n我最喜欢的 mocking 框架是 Mockito，但如果你愿意，也可以研究下 PowerMock 或 JMock。\nSpock框架\nSpock 是另一个测试和规范框架，用于 Java 和 Groovy 应用程序。由于使用 Groovy 编写，Spock 成为一种兼具丰富表现力且简明扼要的规范语言。\n当你使用 Spock 时，你的测试将变得更容易阅读和维护，这得益于它采用的 JUnit 运行器，Spock 兼容大部分 IDE，构建工具和持续集成服务器。\n可惜我没有找到有助于学习 Spock 框架的课程，但阅读《Java Testing with Spock》这本书是很好的开始。\n\nCucumber\nCucumber 是另一个重要的自动化集成测试工具，但与其它同类别的工具不同的是它能够针对规格文档进行自动化测试。\nCucumber 将规格文档和测试文档合成整个动态文档，同时 Cucumber 自动测试这个文档，使测试规范始终保持在最新版本。\n\nSpring Test\nSpring MVC 自带一个很有用的测试框架，它可以在不引入 Web 容器的情况下进行深入测试。\nSpring Test 是为 Spring 程序编写自动化测试的最有用的库之一。为了给 Spring 驱动的应用程序（包括 MVC 控制器在内），编写单元测试和集成测试，Spring Test 提供了一流的支持。\n另外，Spring Test DbUnit 集成了 Spring Test 框架与 DbUnit；Spring Test MVC HtmlUnit 集成了Spring Test MVC 框架和 HtmlUnit。\n通过使用这些工具，你可以轻松地自动测试 Spring MVC 应用程序。\nDBUnit\n数据库是许多 Java 应用程序，包括核心 Java 和 Web 应用程序中不可或缺的部分，也有可能是单元测试的最大障碍。\n在进行集成测试时，连接开发环境或用户验收测试的数据库并不可靠，因为任何人都可以更改数据模式和数据本身，例如表和存储过程等，这会导致自动化集成测试失败。\nDbUnit 是一个 JUnit 扩展，每次集成测试前，将数据库初始化成已知状态，确保数据库存储正确的数据。\nDbUnit 自身还存在着一些问题，但它是一个非常有用的工具，因为它可以帮助我们分离测试数据与测试代码。\n\nRobot 框架\nRobot 框架是一个基于 Python 的通用测试自动化框架，用于验收测试和验收测试驱动开发。\n它是一个由关键字驱动的，使用表格测试数据语法的测试框架，可以用来测试那些涉及多种技术和接口的分布式异构应用。\n如果你打算学习这个优秀的集成测试框架，那么你可以从 Udemy 上的《Robot 框架测试自动化》的课程开始，这是一个很好的学习资源。\n该课程涵盖了两部分内容，Robot 框架基础和高级特性。\n\n结论\n以上列举了Java 程序员需要用到的单元测试和集成测试工具，框架和库。\n还有很多库没有包括在这个列表中，例如 AssertJ 和 Hamcrest，它们可以帮助你写出漂亮且流畅的测试，但学习需要一步步来。\n首先，学习一个可以应用于日常工作的工具或库。 例如，如果你正在使用 Java UI，那么首先应该学习 Selenium，这样你可以有更多时间专注在这个工具上。\n同样的，如果你的工作内容是 REST API，请学习 REST Assured（参阅 REST with Spring）；如果你正在做很多核心 Java 的工作，那么 JUnit 5 可能是你首先需要关注的库。\n\n\r\n        \r\n        \r\n        \n    \n         1 赞\n          收藏\n\n                      评论\n        \n        \n        \n        \n        \n            \n            \n            \n            \n            \n        \n\n    \n\n\n\n\r\n        \r\n\r\n\r\n\t\r\n\t\r\n\t关于作者：搬砖大师傅\r\n\t\r\n\t\r\n\t\t\r\n\t\t\t\r\n\t\t\r\n\t\r\n\r\n    \r\n\r\n        \r\n            对大数据，金融IT开发有兴趣，对量化交易有兴趣        \r\n        \r\n             个人主页 ·\r\n             我的文章\r\n\r\n             ·  10 ·", "tags": "工具与资源,Groovy,java,JUnit", "cover_url_path": "full/d21139b01c705ad942c01fc98ce02e6dc9a5a1c3.jpg"}
